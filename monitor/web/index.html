<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ML-Agents Live Monitor</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg: #0b1220;
      --panel: rgba(255,255,255,0.05);
      --panel-strong: rgba(255,255,255,0.1);
      --card: #f9fafb;
      --card-border: #d8e1ef;
      --text: #eaf1ff;
      --muted: #9fb0cd;
      --muted-dark: #4b5563;
      --accent: #38bdf8;
      --accent-2: #f97316;
      --accent-3: #22c55e;
      --accent-4: #f43f5e;
      --accent-5: #a855f7;
      --border: rgba(255,255,255,0.14);
      --shadow: 0 20px 60px rgba(0,0,0,0.45);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", "Segoe UI", sans-serif;
      background: radial-gradient(120% 120% at 20% 20%, rgba(56,189,248,0.08), transparent 40%),
                  radial-gradient(100% 100% at 80% 10%, rgba(244,63,94,0.08), transparent 30%),
                  radial-gradient(120% 120% at 50% 80%, rgba(34,197,94,0.06), transparent 35%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 24px;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 18px;
    }
    .title {
      font-weight: 700;
      letter-spacing: -0.01em;
      font-size: clamp(24px, 4vw, 32px);
    }
    .subtitle {
      color: var(--muted);
      margin-top: 4px;
      font-size: 14px;
    }
    .badge {
      background: linear-gradient(120deg, rgba(56,189,248,0.25), rgba(244,63,94,0.22));
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 12px;
      font-weight: 600;
      font-size: 14px;
      box-shadow: var(--shadow);
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px 16px;
      box-shadow: var(--shadow);
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      align-items: end;
    }
    label {
      display: block;
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 6px;
      letter-spacing: 0.01em;
    }
    select, input[type="number"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--panel-strong);
      color: var(--text);
      font-size: 14px;
      outline: none;
    }
    .button {
      background: linear-gradient(120deg, #38bdf8, #22c55e);
      color: #04111f;
      font-weight: 700;
      border: none;
      border-radius: 12px;
      padding: 12px 14px;
      cursor: pointer;
      box-shadow: var(--shadow);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    .button.secondary {
      background: rgba(255,255,255,0.82);
      color: #0f172a;
      border: 1px solid var(--card-border);
    }
    .button:active { transform: translateY(1px); box-shadow: none; }
    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }
    .chip {
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.9);
      border: 1px solid var(--card-border);
      color: #0f172a;
      cursor: pointer;
      transition: background 120ms ease;
      font-size: 13px;
    }
    .chip.active {
      background: rgba(56,189,248,0.2);
      border-color: rgba(56,189,248,0.6);
      color: #0b1220;
    }
    .charts {
      margin-top: 14px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(420px, 1fr));
      gap: 20px;
    }
    .chart-card {
      background: var(--card);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 14px 16px 18px 16px;
      min-height: 360px;
      height: 420px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .chart-note {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted-dark);
      background: rgba(255,255,255,0.65);
      border: 1px solid #000000;
      border-radius: 10px;
      padding: 6px 8px;
    }
    canvas {
      width: 100% !important;
      flex: 1 1 auto;
      min-height: 180px;
    }
    .chart-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #0f172a;
      font-size: 13px;
      margin-bottom: 6px;
      font-weight: 700;
    }
    .status {
      color: var(--muted);
      font-size: 13px;
      margin-top: 8px;
    }
    @media (max-width: 720px) {
      body { padding: 16px; }
      .controls { grid-template-columns: 1fr; }
      .charts { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <div class="title">Live Training Monitor</div>
      <div class="subtitle">Track reward, stability, and policy health while ML-Agents trains.</div>
    </div>
    <div class="badge" id="statusBadge">Idle</div>
  </header>

  <div class="panel" style="margin-bottom: 12px;">
    <div class="controls">
      <div>
        <label for="runSelect">Run</label>
        <select id="runSelect"></select>
      </div>
      <div>
        <label for="behaviorSelect">Behavior</label>
        <select id="behaviorSelect"></select>
      </div>
      <div>
        <label for="intervalInput">Refresh (seconds)</label>
        <input type="number" id="intervalInput" value="5" min="1" max="120" />
      </div>
      <div style="display:flex; gap:8px;">
        <button class="button" id="refreshBtn" style="flex:1;">Refresh now</button>
        <button class="button secondary" id="autoBtn" style="flex:1;">Auto: On</button>
      </div>
    </div>
    <div class="chips" id="tagChips"></div>
    <div class="status" id="runMeta"></div>
  </div>

  <div class="panel" style="margin-bottom: 12px;">
    <div class="chart-title" style="color: var(--text); font-weight: 700; margin-bottom: 8px;">Analysis</div>
    <div id="analysisCards" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:10px;"></div>
    <div id="analysisNarrative" style="margin-top:10px; color:var(--muted); font-size:13px; line-height:1.65; background:rgba(255,255,255,0.06); border:1px solid var(--border); border-radius:12px; padding:10px;"></div>
  </div>

  <div class="charts" id="charts"></div>

  <script>
    const runSelect = document.getElementById("runSelect");
    const behaviorSelect = document.getElementById("behaviorSelect");
    const intervalInput = document.getElementById("intervalInput");
    const refreshBtn = document.getElementById("refreshBtn");
    const autoBtn = document.getElementById("autoBtn");
    const chartsContainer = document.getElementById("charts");
    const tagChips = document.getElementById("tagChips");
    const statusBadge = document.getElementById("statusBadge");
    const runMeta = document.getElementById("runMeta");
    const analysisCards = document.getElementById("analysisCards");
    const analysisNarrative = document.getElementById("analysisNarrative");

    let availableTags = [];
    let runData = [];
    const highlightedTags = [
      "Environment/Cumulative Reward",
      "Environment/Episode Length",
      "Policy/Extrinsic Reward",
      "Policy/Loss",
      "Policy/Entropy",
      "Losses/Value Loss"
    ];
    let selectedTags = new Set();
    let charts = {};
    let autoTimer = null;

    const palette = [
      "#0ea5e9",
      "#f97316",
      "#22c55e",
      "#a855f7",
      "#ef4444",
      "#eab308",
      "#14b8a6"
    ];

    function quantile(sortedValues, q) {
      const n = sortedValues.length;
      if (n === 0) return 0;
      const pos = (n - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sortedValues[base + 1] !== undefined) {
        return sortedValues[base] + rest * (sortedValues[base + 1] - sortedValues[base]);
      }
      return sortedValues[base];
    }

    function linearTrend(points) {
      if (!points || points.length < 2) return 0;
      const xs = points.map(p => p.step);
      const ys = points.map(p => p.value);
      const n = xs.length;
      const meanX = xs.reduce((a,b)=>a+b,0)/n;
      const meanY = ys.reduce((a,b)=>a+b,0)/n;
      let num=0, den=0;
      for (let i=0;i<n;i++){
        const dx = xs[i]-meanX;
        num += dx*(ys[i]-meanY);
        den += dx*dx;
      }
      return den === 0 ? 0 : num/den;
    }

    function calcRange(values) {
      const finite = values.filter(Number.isFinite).sort((a, b) => a - b);
      if (!finite.length) return { min: -1, max: 1 };
      const lo = quantile(finite, 0.05);
      const hi = quantile(finite, 0.95);
      const span = Math.max(hi - lo, 1e-3);
      const pad = span * 0.1;
      return { min: lo - pad, max: hi + pad };
    }

    function describeTag(tag) {
      const map = {
        "Environment/Cumulative Reward": "Total reward per episode (unitless). Upward slope = improving policy; sustained drops = failing episodes or bad shaping.",
        "Environment/Episode Length": "Number of steps per episode (steps). High = long or stuck episodes; very low = quick success or quick failure. Stable midrange is usually healthy.",
        "Policy/Extrinsic Reward": "Extrinsic reward collected (unitless). Mirrors how well the agent is earning environment rewards; should correlate with cumulative reward.",
        "Policy/Loss": "Policy loss (unitless). Should trend down and stabilize; large spikes indicate unstable updates or overly strong gradients.",
        "Policy/Entropy": "Policy entropy (nats). Starts high (exploration) and should taper as the policy commits; late rises can signal dithering.",
        "Losses/Value Loss": "Critic loss (unitless). Stable low values mean good value estimation; spikes suggest the critic is struggling to fit returns."
      };
      return map[tag] || "Scalar from training logs for this behavior.";
    }

    function yLabel(tag) {
      const map = {
        "Environment/Cumulative Reward": "Cumulative reward (per episode)",
        "Environment/Episode Length": "Steps per episode",
        "Policy/Loss": "Policy loss",
        "Policy/Entropy": "Entropy (nats)",
        "Losses/Value Loss": "Value loss",
        "Policy/Extrinsic Reward": "Extrinsic reward"
      };
      return map[tag] || "Value";
    }

    function cleanValues(values) {
      return values
        .map(v => Number.isFinite(v) ? v : null)
        .filter(v => v !== null);
    }

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) {
        const msg = await res.text();
        throw new Error(msg || res.statusText);
      }
      return res.json();
    }

    function setStatus(text, tone = "info") {
      statusBadge.textContent = text;
      const colors = {
        info: "linear-gradient(120deg, rgba(56,189,248,0.25), rgba(34,197,94,0.2))",
        warn: "linear-gradient(120deg, rgba(250,204,21,0.35), rgba(249,115,22,0.25))",
        error: "linear-gradient(120deg, rgba(244,63,94,0.35), rgba(248,113,113,0.25))",
      };
      statusBadge.style.background = colors[tone] || colors.info;
    }

    function fmtTime(sec) {
      const dt = new Date(sec * 1000);
      return dt.toLocaleString();
    }

    function renderChips(tags) {
      availableTags = tags;
      if (!tags.length) {
        tagChips.innerHTML = "<span style='color:var(--muted)'>No scalar tags found yet.</span>";
        return;
      }
      // default selection
      if (!selectedTags.size) {
        highlightedTags.forEach(tag => { if (tags.includes(tag)) selectedTags.add(tag); });
        if (!selectedTags.size) selectedTags = new Set(tags.slice(0, Math.min(4, tags.length)));
      }
      tagChips.innerHTML = "";
      tags.forEach(tag => {
        const chip = document.createElement("div");
        chip.className = "chip" + (selectedTags.has(tag) ? " active" : "");
        chip.textContent = tag;
        chip.onclick = () => {
          if (selectedTags.has(tag)) {
            selectedTags.delete(tag);
          } else {
            selectedTags.add(tag);
          }
          chip.classList.toggle("active");
          drawCharts(latestMetrics);
        };
        tagChips.appendChild(chip);
      });
    }

    let latestMetrics = null;

    function upsertChart(tag, points) {
      if (!points || !points.length) {
        return;
      }
      const labels = points.map(p => p.step);
      const values = cleanValues(points.map(p => p.value));
      const color = palette[Object.keys(charts).length % palette.length];
      const range = calcRange(values);
      const areaPattern = (() => {
        const p = document.createElement("canvas");
        p.width = 32;
        p.height = 32;
        const ctx = p.getContext("2d");
        const grad = ctx.createLinearGradient(0, 0, 0, 32);
        grad.addColorStop(0, color + "33");
        grad.addColorStop(1, color + "08");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);
        return ctx.createPattern(p, "repeat");
      })();

      if (charts[tag]) {
        charts[tag].data.labels = labels;
        charts[tag].data.datasets[0].data = values;
        charts[tag].options.scales.y.min = range.min;
        charts[tag].options.scales.y.max = range.max;
        charts[tag].update("none");
        return;
      }

      const card = document.createElement("div");
      card.className = "chart-card";
      const title = document.createElement("div");
      title.className = "chart-title";
      title.innerHTML = `<span>${tag}</span><span>latest: ${values[values.length - 1].toFixed(3)}</span>`;
      const canvas = document.createElement("canvas");
      card.appendChild(title);
      card.appendChild(canvas);
      const note = document.createElement("div");
      note.className = "chart-note";
      note.textContent = describeTag(tag);
      card.appendChild(note);
      chartsContainer.appendChild(card);

      const ctx = canvas.getContext("2d");
      charts[tag] = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [{
            label: tag,
            data: values,
            borderColor: color,
            backgroundColor: areaPattern,
            tension: 0.2,
            borderWidth: 3.2,
            pointRadius: 0,
            fill: true,
          }],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 8, right: 8, bottom: 18, left: 8 } },
          animation: false,
          scales: {
            x: {
              ticks: { color: "#334155", maxTicksLimit: 6 },
              grid: { color: "rgba(15,23,42,0.08)" },
              title: { display: true, text: "Training step", color: "#334155", font: { weight: "600" } }
            },
            y: {
              ticks: { color: "#334155" },
              grid: { color: "rgba(15,23,42,0.08)" },
              min: range.min,
              max: range.max,
              title: { display: true, text: yLabel(tag), color: "#334155", font: { weight: "600" } }
            },
          },
          plugins: {
            legend: { display: false },
            title: { display: true, text: describeTag(tag), align: "start", color: "#0f172a", font: { size: 12, weight: "600" } },
            tooltip: {
              callbacks: {
                title: (items) => `Step ${items[0].label}`,
                label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(4)}`
              }
            }
          },
        },
      });
    }

    function drawCharts(metrics) {
      latestMetrics = metrics;
      chartsContainer.innerHTML = "";
      charts = {};
      if (!metrics || !metrics.tags?.length) {
        chartsContainer.innerHTML = "<div style='color:var(--muted); padding:16px;'>No metrics yet. Start training to see live data.</div>";
        return;
      }
      const activeTags = metrics.tags.filter(t => selectedTags.has(t));
      if (!activeTags.length) {
        chartsContainer.innerHTML = "<div style='color:var(--muted); padding:16px;'>Select at least one metric above.</div>";
        return;
      }
      activeTags.forEach(tag => upsertChart(tag, metrics.data[tag]));
    }

    function summarizeSeries(points) {
      if (!points || !points.length) return null;
      const vals = cleanValues(points.map(p => p.value));
      if (!vals.length) return null;
      const steps = points.map(p => p.step);
      return {
        last: vals[vals.length - 1],
        best: Math.max(...vals),
        median: quantile([...vals].sort((a,b)=>a-b), 0.5),
        p05: quantile([...vals].sort((a,b)=>a-b), 0.05),
        p95: quantile([...vals].sort((a,b)=>a-b), 0.95),
        trend: linearTrend(points)
      };
    }

    function renderAnalysis(data) {
      analysisCards.innerHTML = "";
      analysisNarrative.textContent = "";
      if (!data || !data.tags?.length) {
        analysisNarrative.textContent = "No metrics yet.";
        return;
      }
      const reward = summarizeSeries(data.data["Environment/Cumulative Reward"]);
      const length = summarizeSeries(data.data["Environment/Episode Length"]);
      const entropy = summarizeSeries(data.data["Policy/Entropy"]);
      const policyLoss = summarizeSeries(data.data["Policy/Loss"]);

      const cards = [];
      if (reward) {
        cards.push({
          title: "Cumulative Reward",
          value: reward.last.toFixed(2),
          detail: `best ${reward.best.toFixed(2)}, median ${reward.median.toFixed(2)}, trend ${reward.trend >=0 ? "up" : "down"} (unitless)`
        });
      }
      if (length) {
        cards.push({
          title: "Episode Length",
          value: length.last.toFixed(1),
          detail: `median ${length.median.toFixed(1)}, p95 ${length.p95.toFixed(1)} (steps)`
        });
      }
      if (entropy) {
        cards.push({
          title: "Policy Entropy",
          value: entropy.last.toFixed(3),
          detail: `trend ${entropy.trend >=0 ? "rising" : "falling"} (nats)`
        });
      }
      if (policyLoss) {
        cards.push({
          title: "Policy Loss",
          value: policyLoss.last.toFixed(3),
          detail: `best ${policyLoss.best.toFixed(3)}, median ${policyLoss.median.toFixed(3)} (unitless)`
        });
      }

      cards.forEach(c => {
        const el = document.createElement("div");
        el.className = "chart-card";
        el.style.height = "auto";
        el.style.minHeight = "auto";
        el.innerHTML = `<div class="chart-title" style="color:#0f172a;"><span>${c.title}</span><span>${c.value}</span></div><div class="chart-note" style="background:#f8fafc;">${c.detail}</div>`;
        analysisCards.appendChild(el);
      });

      const notes = [];
      if (reward && length) {
        if (length.last > 2000 && reward.last < 0) {
          notes.push("Episodes are very long with negative reward \u2192 likely stalling/exploit (e.g., running away from goals).");
        } else if (reward.trend > 0 && length.median < 600) {
          notes.push("Reward trending up with moderate episode length \u2192 policy is converging toward stable goal crossings.");
        }
        if (reward.last > 200 && length.median < 400) {
          notes.push("High reward with short-to-moderate episodes \u2192 successful back-and-forth goal collection (similar to Model 20).");
        }
      }
      if (entropy && entropy.trend > 0 && reward && reward.trend < 0) {
        notes.push("Entropy rising while reward falls \u2192 policy may be dithering; consider reducing exploration or curiosity.");
      }
      if (policyLoss && policyLoss.p95 > policyLoss.median * 2) {
        notes.push("Policy loss spikes detected \u2192 instability; check learning rate or reward scale.");
      }
      analysisNarrative.innerHTML = notes.length
        ? notes.map(n => `<div>${n}</div>`).join("")
        : "No major issues detected. Watching reward slope and episode length for stability.";
    }

    async function loadRuns() {
      setStatus("Loading runs...");
      try {
        const { runs } = await fetchJson("/api/runs");
        runData = runs || [];
        if (!runData.length) {
          setStatus("No runs found", "warn");
          runSelect.innerHTML = "";
          behaviorSelect.innerHTML = "";
          return;
        }
        runSelect.innerHTML = runData
          .map(r => `<option value="${r.id}">${r.id}</option>`)
          .join("");
        const latest = runData[runData.length - 1];
        runSelect.value = latest.id;
        populateBehaviors(latest);
        await loadMetrics();
        setStatus("Live");
      } catch (err) {
        console.error(err);
        setStatus("Error loading runs", "error");
      }
    }

    function populateBehaviors(run) {
      if (!run) {
        behaviorSelect.innerHTML = "";
        return;
      }
      behaviorSelect.innerHTML = (run.behaviors || [])
        .map(b => `<option value="${b.name}">${b.name}</option>`)
        .join("");
      if (run.behaviors?.length) {
        behaviorSelect.value = run.behaviors[0].name;
      }
    }

    async function loadMetrics() {
      const run = runSelect.value;
      const behavior = behaviorSelect.value;
      if (!run || !behavior) return;
      try {
        const limit = 2000; // maximum window for full-curve visibility
        setStatus("Updating...");
        const data = await fetchJson(`/api/metrics?run=${encodeURIComponent(run)}&behavior=${encodeURIComponent(behavior)}&limit=${limit}`);
        renderChips(data.tags || []);
        drawCharts(data);
        const lastTag = data.tags.find(t => data.data[t]?.length);
        const lastStep = lastTag ? data.data[lastTag].slice(-1)[0].step : "-";
        runMeta.textContent = `Run ${data.run} | Behavior ${data.behavior} | Last training step ${lastStep}`;
        renderAnalysis(data);
        setStatus("Live");
      } catch (err) {
        console.error(err);
        setStatus("Error fetching metrics", "error");
      }
    }

    function toggleAuto() {
      if (autoTimer) {
        clearInterval(autoTimer);
        autoTimer = null;
        autoBtn.textContent = "Auto: Off";
        return;
      }
      const intervalSec = Math.max(1, Number(intervalInput.value) || 5);
      autoBtn.textContent = "Auto: On";
      autoTimer = setInterval(loadMetrics, intervalSec * 1000);
    }

    runSelect.onchange = () => {
      const selected = runData.find(r => r.id === runSelect.value);
      populateBehaviors(selected);
      loadMetrics();
    };
    behaviorSelect.onchange = loadMetrics;
    refreshBtn.onclick = loadMetrics;
    autoBtn.onclick = toggleAuto;

    loadRuns();
    toggleAuto(); // start auto-refresh by default
  </script>
</body>
</html>
